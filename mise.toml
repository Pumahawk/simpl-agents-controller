# -----------------------------------------------------------------------------
# ESCAPE-REF: KC-MISE-QUOTE-001
#
# This task embeds a multiline shell script inside a single-quoted string
# passed to `bash -c` via `kubectl exec`.
#
# IMPORTANT:
# The outer layer uses single quotes ('...') to prevent the local shell from
# performing variable expansion or interpretation before the script reaches
# the container.
#
# Because of this, ANY single quote character inside the embedded script
# will terminate the outer string and break parsing.
#
# In shell, single quotes cannot be escaped inside single-quoted strings.
# The only safe ways to include a single quote are:
#
#   1) Close and reopen the quote:
#        'foo'\''bar'
#
#   2) Avoid single quotes entirely inside the embedded script.
#
# Why this matters:
# The evaluation chain is:
#     mise template expansion
#     → local bash parsing
#     → kubectl exec
#     → container bash -c parsing
#
# The outer single quotes ensure the script is passed RAW to the container.
# Breaking this quoting breaks the entire execution model.
#
# If modifying the embedded script, ensure it does not contain unescaped
# single quotes.
# -----------------------------------------------------------------------------

[tools]
kubectl = "1.34.1"
jq = "1.8.1"
yq = "4.47.2"

[env]
KUBECONFIG = "__REQUIRED_OVERRIDE__"
FQDN_SUFFIX=".sandbox-iaa.simpl-europe.eu"
TIER2_FQDN_PREFIX="tls."

# See ESCAPE-REF: KC-MISE-QUOTE-001
[vars]
keycloak_sh = """
kgetpass() {
  cat /opt/bitnami/keycloak/secrets/admin-password
}
kcadm() {
  local action="${1?Missing action}"
  shift
  local pass="$(kgetpass)"
  /opt/keycloak/bin/kcadm.sh "$action" --no-config --server http://keycloak --realm master --user admin --password $pass "$@"
}
"""

[tasks."cluster:authority_initialization_by_namespace"]
shell = "bash -ec"
run = """
cluster_authority_initialization_by_namespace() {
local K_NAMESPACE="${1?Missing namespace}"
if [[ ! "$K_NAMESPACE" =~ authority ]]; then
  >&2 echo "Namespace must be an authority"
  return 1
fi

AUTH_PF_PORT=8105
ID_PF_PORT=8103

AUTH_SERVICE=authentication-provider
ID_SERVICE=identity-provider

cleanup() {
  >&2 echo "Stopping port-forwards..."
  [[ -n "$AUTH_PF_PID" ]] && kill "$AUTH_PF_PID" 2>/dev/null || true
  [[ -n "$ID_PF_PID" ]] && kill "$ID_PF_PID" 2>/dev/null || true
}

trap cleanup EXIT INT TERM

>&2 echo "Starting port-forward for $AUTH_SERVICE..."
kubectl port-forward -n "$K_NAMESPACE" svc/$AUTH_SERVICE $AUTH_PF_PORT:8080 >/tmp/auth-pf.log 2>&1 &
AUTH_PF_PID=$!

>&2 echo "Starting port-forward for $ID_SERVICE..."
kubectl port-forward -n "$K_NAMESPACE" svc/$ID_SERVICE $ID_PF_PORT:8080 >/tmp/id-pf.log 2>&1 &
ID_PF_PID=$!

wait_for_port() {
  local port=$1
  for i in {1..20}; do
    if nc -z localhost "$port"; then
      return 0
    fi
    sleep 0.5
  done
  >&2 echo "Port $port not available"
  return 1
}

>&2 echo "Waiting for port-forwards to be ready..."
wait_for_port $AUTH_PF_PORT
wait_for_port $ID_PF_PORT

export AUTHORITY_AUTH_PROVIDER=localhost:$AUTH_PF_PORT
export AUTHORITY_IDENTITY_PROVIDER=localhost:$ID_PF_PORT

>&2 echo Generating keypair...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/keypairs/generate"

>&2 echo Generating CSR...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/csr/generate" \
--header 'Content-Type: application/json' \
--data-raw '{
  "commonName": "'"${TIER2_FQDN_PREFIX}${K_NAMESPACE}${FQDN_SUFFIX}"'",
  "country": "it",
  "organization": "'"${K_NAMESPACE}"'",
  "organizationalUnit": "'"${K_NAMESPACE}"'"
}' > csr.pem

>&2 echo Creating Authority participant
PARTICIPANT_ID=$(curl -v -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants" \
--header 'Content-Type: application/json' \
--data-raw '{
  "organization": "'"${K_NAMESPACE}"'",
  "participantType": "GOVERNANCE_AUTHORITY"
}' | sed -E 's/^"(.*)"$/\\1/')

>&2 echo Uploading CSR ..
>&2 echo "Participant id: $PARTICIPANT_ID"
curl -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants/$PARTICIPANT_ID/csr" \
-F "csr=@csr.pem"

>&2 echo Downloading credentials ...
curl "$AUTHORITY_IDENTITY_PROVIDER/v1/credentials/$PARTICIPANT_ID/download" \
-o cert.pem

>&2 echo Uploading credentials ...
curl -v -H "Authorization: Bearer $TMP_TOKEN" -X POST "$AUTHORITY_AUTH_PROVIDER/v1/credentials" \
-F "credential=@cert.pem"
}
cluster_authority_initialization_by_namespace
"""
# sandbox-iaa/consumer01-postgres-passwords
[tasks."cluster:secrets"]
shell = "bash -c"
run = """
function main() {
  SECRET_KEY="$1"
  shift;
  T_BAO=$(kubectl -n common01 get secret secrets-root-token -o jsonpath="{.data.token}" | base64 -d)
  (
  kubectl -n common01 exec -i openbao-common01-0 -- sh -b << EOF
  >&2 bao login "$T_BAO" \
  && bao kv get -format=json $@ "$SECRET_KEY"
EOF
  ) | cat
}
main
"""

[tasks."cluster:db:exec"]
run = "kubectl exec -n common01 pg-cluster-2 -- psql -U postgres"

[tasks."cluster:db:connect"]
run = "kubectl exec -it -n common01 pg-cluster-2 -- psql -U postgres"

[tasks."cluster:db:get_connections_by_user"]
shell = "bash -ec"
run = """
# Get db connections
db_get_connections() {
local USER="${1?Missing user}"
mise run cluster:db:connect -- -c " SELECT 'service-$USER' as name, count(*) AS numero_connessioni FROM pg_stat_activity WHERE usename = '$USER'; "
}
db_get_connections
"""

[tasks."cluster:db:get_connections_all"]
shell = "bash -ec"
run = """
# Get db connections
db_get_connections() {
kubectl exec -n common01 pg-cluster-2 -- psql -U postgres -c "
SELECT 
    usename AS name,
    COUNT(*) AS numero_connessioni
FROM 
    pg_stat_activity
GROUP BY 
    usename
ORDER BY 
    numero_connessioni DESC;
"

}
db_get_connections
"""

[tasks."db:drop_all_tables"]
shell = "bash -ec"
run = """
drop_all_tables() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: drop_all_tables <namespace> <db_user>"
    return 1
  fi

  local DB_PASS="$(mise run db:get_password "$K_NAMESPACE" "$DB_USER")"

  # --- Parameter validation ---
  if [[ -z "$DB_PASS" ]]; then
    echo "ERROR: Missing required parameters."
    echo "ERROR: Missing password"
    return 1
  fi

  echo "Connecting to database as ${K_NAMESPACE}_${DB_USER}..."

  kubectl exec -i -n common01 pg-cluster-2 -- sh -c "
    export PGPASSWORD='${DB_PASS}';
    psql --host=pg-cluster -U ${K_NAMESPACE}_${DB_USER} <<'SQL'
DO \\$\\$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    )
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS public.'
                || quote_ident(r.tablename)
                || ' CASCADE';
    END LOOP;
END
\\$\\$;
SQL
"

  if [[ $? -ne 0 ]]; then
    echo "ERROR: Failed to drop tables."
    return 1
  fi

  echo "All tables in schema 'public' have been dropped successfully."
}
drop_all_tables
"""

[tasks."db:get_password"]
shell = "bash -ec"
run = """
get_password() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_password <namespace> <db_user>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/"$K_NAMESPACE"-postgres-passwords | jq -r '.data.data."'"${K_NAMESPACE}-${DB_USER}"'"'
}
get_password
"""

[tasks."db:get_secrets"]
shell = "bash -ec"
run = """
get_secrets() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_secrets <namespace>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/${K_NAMESPACE}-postgres-passwords
}
get_secrets
"""

[tasks."db:clear_agent"]
shell = "bash -ec"
run = """
clear_agent() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: clear_agent <namespace>"
    return 1
  fi

   # Participant
   mise run db:drop_all_tables "$K_NAMESPACE" authenticationprovider
   mise run db:drop_all_tables "$K_NAMESPACE" usersroles
   mise run db:drop_all_tables "$K_NAMESPACE" keycloak

   if echo "$K_NAMESPACE" | grep -q authority; then
     # Authority
     mise run db:drop_all_tables "$K_NAMESPACE" ejbca
     kubectl -n "$K_NAMESPACE" delete secret ejbca-rest-api-secret
     mise run db:drop_all_tables "$K_NAMESPACE" identityprovider
     mise run db:drop_all_tables "$K_NAMESPACE" onboarding
     mise run db:drop_all_tables "$K_NAMESPACE" securityattributesprovider
   fi
}
clear_agent
"""

[tasks."keycloak:kcadm"]
shell = "bash -ec"
run = """
keycloak_kcadm() {
  local K_NAMESPACE="${1?"Missing namespace"}"; shift
  kubectl -n "$K_NAMESPACE" exec -i keycloak-0 -- bash -c '{{vars.keycloak_sh}} kcadm $@' -- "$@"
}
keycloak_kcadm
"""
[tasks."keycloak:cli"]
shell = "bash -ec"
run = """
keycloak_cli() {
local K_NAMESPACE="${1?"Missing namespace"}"
kubectl -it -n "$K_NAMESPACE" exec keycloak-0 -- bash -c "
bash --init-file <( echo -e '"'{{vars.keycloak_sh}}'"' ) -i
"
}
keycloak_cli
"""

[tasks."services:info"]
shell = "bash -ec"
run = """
services_endpoints() {
  local project_name="${1?Missing project}"
  local chart_file="simpl-repo/$project_name/charts/values.yaml"
  [ -f "$chart_file" ] || {
     echo "Invalid project."
     return 1;
  }
  cat "$chart_file" | yq -ojson | jq 'to_entries[] | select((.value|type)=="object" and .value.projectID!=null) | {name:.key, projectID:.value.projectID, version: .value.targetRevision, repo:"https://code.europa.eu/api/v4/projects/\\(.value.projectID)/packages/helm/stable"}' 
}
services_endpoints
"""

[tasks."services:info-table"]
shell = "bash -ec"
run = """
services_info_table() {
   local project_name="${1?Missing project}"
   mise services:info "$project_name" | jq -r '"\\(.name),\\(.version)"' | column -s, -t
}
services_info_table
"""

[tasks."services:versions_by_type_and_projectID"]
shell = "bash -ec"
run = """
services_versions_by_type_and_projectID() {
  local TYPE_AND_PROJECT_ID="${1?Missing type and project}"
  local TYPE="$(echo "$TYPE_AND_PROJECT_ID" | cut -d, -f 1)"
  local PROJECT_ID="$(echo "$TYPE_AND_PROJECT_ID" | cut -d, -f 3)"
  case "${TYPE?"Missing type"}" in
    helm)
      mise run services:helm_versions_by_projectID "${PROJECT_ID?"Missing projectID"}"
    ;;
    jar)
      mise run services:jar_versions_by_projectID "${PROJECT_ID?"Missing projectID"}"
    ;;
    *)
      >&2 echo "Not supported type [$TYPE]"
      return 1
    ;;
   esac
}
services_versions_by_type_and_projectID
"""

[tasks."services:jar_versions_by_projectID"]
shell = "bash -ec"
run = """
services_jar_versions_by_projectID() {
  local project_id="${1?Missing project ID}"
  curl -s -w "%{stderr}Http response code: %{http_code}\\n" "https://code.europa.eu/api/v4/projects/${project_id}/maven-metadata.xml" | yq -r -p xml .metadata.versioning.versions.version[] | tac
}
services_jar_versions_by_projectID
"""

[tasks."services:helm_versions_by_projectID"]
shell = "bash -ec"
run = """
services_helm_versions_by_projectID() {
  local project_id="${1?Missing project ID}"
  curl -s -w "%{stderr}Http response code: %{http_code}\\n" "https://code.europa.eu/api/v4/projects/$project_id/packages/helm/stable/index.yaml" | yq -o json -r '.entries[] | sort_by(.created) | reverse | .[].version'
}
services_helm_versions_by_projectID
"""

[tasks."keycloak:config:eidas_fe"]
shell = "bash -ec"
run = """
keycloak_config_eidas_fe() {
local K_NAMESPACE="${1?Missing namespace}"
local CLIENT_ID="$(mise run keycloak:cli "$K_NAMESPACE" <<<"kcadm get realms/authority/clients -q clientId=frontend-cli" | yq -r -pjson '.[] | select(.clientId == "frontend-cli") | .id')"

mise run keycloak:cli "$K_NAMESPACE" <<KCLI_EOF
kcadm create realms/authority/client-scopes -f - <<EOF
{
    "id": "527329d0-ff88-4776-a6d3-12cca0ed5145",
    "name": "onboarding",
    "description": "",
    "protocol": "openid-connect",
    "attributes": {
        "include.in.token.scope": "false",
        "display.on.consent.screen": "true",
        "gui.order": "",
        "consent.screen.text": "",
        "include.in.openid.provider.metadata": "true"
    },
    "protocolMappers": [
        {
            "id": "60dc0e7b-fe5a-4335-b24c-5beecc06bd97",
            "name": "Hardcoded Role",
            "protocol": "openid-connect",
            "protocolMapper": "oidc-hardcoded-role-mapper",
            "consentRequired": false,
            "config": {
                "role": "APPLICANT"
            }
        },
        {
            "id": "0202e9a2-0d66-41c4-a495-b818140cdb76",
            "name": "User Realm Role",
            "protocol": "openid-connect",
            "protocolMapper": "oidc-usermodel-realm-role-mapper",
            "consentRequired": false,
            "config": {
                "introspection.token.claim": "true",
                "multivalued": "true",
                "userinfo.token.claim": "true",
                "id.token.claim": "true",
                "lightweight.claim": "false",
                "access.token.claim": "true",
                "claim.name": "client-roles",
                "jsonType.label": "String"
            }
        }
    ]
}
EOF
KCLI_EOF

mise run keycloak:cli "$K_NAMESPACE" <<<"kcadm update realms/authority/clients/$CLIENT_ID/optional-client-scopes/527329d0-ff88-4776-a6d3-12cca0ed5145"
}
keycloak_config_eidas_fe
"""

[tasks."services:last_version"]
shell = "bash -ec"
run = """
services_last_version() {
  local repo_name="${1?"Missing repo name"}"
  local project_name="${2?"Missing project name"}"
  local project_id="$(mise run services:info authority-iaa | jq -r 'select(.name == "'"$project_name"'") | .projectID')"
  echo $project_name $(mise services:versions_by_type_and_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)
}
services_last_version
"""

[tasks."services:all_last_version"]
shell = "bash -ec"
run = """
services_all_last_version() {
  local repo_name="${1?"Missing repo name"}"
  mise run services:info $repo_name | jq -r '"\\(.name)|\\(.projectID)"' |
  while read line; do
    local project_name="$(echo -e $line | cut -d\\| -f1)"
    local project_id="$(echo -e $line | cut -d\\| -f2)"
    echo $project_name "$(mise services:versions_by_type_and_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)"
  done
}
services_all_last_version
"""

[tasks."yaml:argo_app:update_target_revision"]
shell = "bash -ec"
dir = "{{cwd}}"
run = """
update_target_revision() {
  local file="${1?Missing file path}"
  local name="${2?Missing name}"
  local version="${3?Missing version}"
  yq '(.spec.source.helm.parameters[] | select(.name | test("((^)|(\\.))'"$name"'.targetRevision")) | .value) = "'"$version"'"' "$file"
}
update_target_revision
"""

[tasks."argo:get_updated_application_by_namespace"]
shell = "bash -ec"
run = """
# Functions argo:get_updated_application_by_namespace
function argo_getapp() {
  local K_NAMESPACE="${1?Missing namespace}"
  local ARGO_DEPLOYER="$K_NAMESPACE"-deployer
  log "Get argocd deployer [$ARGO_DEPLOYER]"
  kubectl -n argocd get -oyaml application "$ARGO_DEPLOYER" | yq .
}

function helm_get_last_version_by_project_name() {
  local NAME="${1?Missin project name}"
  shift
  local VERSION_GREP_ARGS=("$@")
  log "Get last version project $NAME"
  local PROJECT_ID_AND_TYPE="$(iaa_get_type_and_projectID_by_projectName "${NAME}")"
  log "Retrieved projectID name=[$NAME] id=[$PROJECT_ID_AND_TYPE]"
  local PROJECT_VERSION="$(mise run services:versions_by_type_and_projectID $PROJECT_ID_AND_TYPE | grep "${VERSION_GREP_ARGS[@]-".*"}" | head -n1)"
  log "Retrieved version name=[$NAME] version=[$PROJECT_VERSION]"
  echo $PROJECT_VERSION
}

function argo_update_versions() {
  K_NAMESPACE="${1?Missing namespace}"
  export LOG_CONTEXT="$K_NAMESPACE"
  shift
  local VERSION_GREP_ARGS=("$@")
  local YAML_TEXT="$(argo_getapp "$K_NAMESPACE")"
  local YAML_ORIGINAL="$YAML_TEXT"
  local VERSION=""
  if [[ "${SKIP_UPDATE_HEAD:-}" != "1" ]]; then
   local CHART_PROJECT_ID="$(echo "$YAML_TEXT" | yq .spec.source.repoURL | grep -o '/[0-9][0-9]*/' | sed 's|/||g')"
   local CHART_VERSION="$(mise run services:versions_by_type_and_projectID helm,,"$CHART_PROJECT_ID" | grep "${VERSION_GREP_ARGS[@]-".*"}" | head -n1)"
    if [[ -n "$CHART_VERSION" && "$CHART_VERSION" != "null" ]]; then
      YAML_TEXT="$(yq '(.spec.source.targetRevision) = "'"$CHART_VERSION"'"'  <(echo "$YAML_TEXT"))"
    else
      log "Invalid version retrieved. Skip update. name=[$NAME]"
    fi
   fi
   while read line; do
    local NAME="$line"
    log "Update version. name=[$NAME]"
    VERSION="$(helm_get_last_version_by_project_name "$NAME" "${VERSION_GREP_ARGS[@]}")"
    if [[ -n "$VERSION" && "$VERSION" != "null" ]]; then
    YAML_TEXT="$(mise run yaml:argo_app:update_target_revision  <(echo "$YAML_TEXT") "$NAME" "$VERSION")"
    else
      log "Invalid version retrieved. Skip update. name=[$NAME]"
    fi
  done < <(echo "$YAML_TEXT" | yq .spec.source.helm.parameters[].name | grep targetRevision | sed 's/\\.targetRevision//;s/^.*\\.//')
  log "Diff .spec.source"
  local diff_exit=0
  set +e
  >&2 diff --color=always -U100 \
    <(echo "$YAML_ORIGINAL" | yq .spec.source) \
    <(echo "$YAML_TEXT" | yq .spec.source)
  diff_exit=$?
  set -e
  echo "$YAML_TEXT" | yq .
  [ $diff_exit != 0 ]
}

function iaa_get_type_and_projectID_by_projectName() {
local NAME="${1?Missin project name}"
cat << 'EOF' | grep -E ",${NAME},"
helm,tier1_gateway,772
helm,sap,861
helm,users_roles,771
helm,fe_auth_provider,1308
helm,authentication_provider_fe,1308
helm,fe_users_roles,1310
helm,fe_identity_provider,1311
helm,fe_onboarding,1307
helm,fe_security_attribute_provider,1309
helm,auth_provider_fe,1308
helm,users_roles_fe,1310
helm,identity_provider_fe,1311
helm,onboarding_fe,1307
helm,security_attribute_provider_fe,1309
helm,onboarding,770
helm,tier2_gateway,860
helm,identity_provider,913
helm,auth_provider,939
helm,tier2_proxy,1112
jar,keycloak_authenticator,915/packages/maven/eu/europa/ec/simpl/keycloak-authenticator
jar,eidas_demo_keycloak_extension,1313/packages/maven/eu/europa/ec/simpl/eidas-demo-keycloak-extension
EOF
}

function log() {
  >&2 echo "$(date -Iseconds) "[${LOG_CONTEXT-"none"}]" -- $1"
}
argo_update_versions
"""

[tasks."argo:update_and_sync_by_namespace"]
shell = "bash -ec"
run = """
argo_update_and_sync() {
local K_NAMESPACE="${1?Missing namespace}"
shift
local VERSION_GREP_ARGS=("$@")
if YAML_TEXT=$(mise run argo:get_updated_application_by_namespace "$K_NAMESPACE" "${VERSION_GREP_ARGS[@]}"); then
  >&2 echo Apply and sync.
  kubectl apply -f <(echo "$YAML_TEXT") && mise run argo:sync "$K_NAMESPACE"
else
  >&2 echo No differences . Skip apply and sync.
fi
}
argo_update_and_sync
"""

[tasks."argo:cli"]
run = "kubectl -n argocd exec argo-cd-argocd-application-controller-0 -- argocd --core "

[tasks."argo:sync"]
shell = "bash -ec"
run = """
argo_sync() {
  K_NAME="${1?Missing namespace}"
  kubectl -n argocd exec argo-cd-argocd-application-controller-0 -- argocd --core app sync "${K_NAME}"-deployer
}
argo_sync
"""

[tasks."argo:sync_all"]
run = """
mise run \\
    argo:sync iaadsdevauthority \\
::: argo:sync iaadsdevconsumer \\
::: argo:sync iaadsdevdataprovider \\
::: argo:sync iaadstestauthority \\
::: argo:sync iaadstestconsumer \\
::: argo:sync iaadstestdataprovider \\
::: argo:sync iaadsstagingauthority \\
::: argo:sync iaadsstagingconsumer \\
::: argo:sync iaadsstagingdataprovider \\
::: argo:sync iaadsautomationauthority \\
::: argo:sync iaadsautomationconsumer \\
::: argo:sync iaadsautomationdataprovider
"""

[tasks."argo:copy_parameters"]
shell = "bash -ec"
run = """
argo_copy_parameters() {
  local K_NAMESPACE_FROM="${1?Missing namespace from}"
  local K_NAMESPACE_TO="${2?Missing namespace to}"
  Y1="$(kubectl -n argocd get application ${K_NAMESPACE_FROM}-deployer -oyaml | yq 'del(.status)')"
  Y2="$(kubectl -n argocd get application ${K_NAMESPACE_TO}-deployer -oyaml | yq 'del(.status)')"
  if [[ -z "$Y1" || "$Y1" == "null" ]]; then
    >&2 echo "Application ${K_NAMESPACE_FROM}-deployer not found or invalid"
    return 1
  fi

  if [[ -z "$Y2" || "$Y2" == "null" ]]; then
    >&2 echo "Application ${K_NAMESPACE_TO}-deployer not found or invalid"
    return 1
  fi
  Y3="$(echo "$Y2" | yq '(.spec.source.targetRevision) = "'"$(echo "$Y1" | yq .spec.source.targetRevision)"'" | (.spec.source.helm.parameters) = '"$(echo "$Y1" | yq -ojson .spec.source.helm.parameters)")"
  set +e
  >&2 echo "Changes:"
  diff --color=always -U100 <( echo "$Y2" ) <( echo "$Y3" )
  local diff_ret_code="$?"
  set -e

  if [ "$diff_ret_code" -eq 1 ]; then
    >&2 echo "Changes detected, applying..."
    echo "$Y3" | kubectl apply -f -
  elif [ "$diff_ret_code" -eq 2 ]; then
    >&2 echo "Diff error!" >&2
    return 1
  else
    >&2 echo "No changes detected"
    return 2
  fi
}
argo_copy_parameters
"""

[tasks."environment:remote_update"]
shell = "bash -ec"
run = """
environment_remote_update() {
  local K_NAME="${1?Missing namespace}"
  local VERSION_GREP_ARGS=( -v -e latest )
  case "$K_NAME" in
    iaadsautomation*|iaadsdev*)
      VERSION_GREP_ARGS=(-P '^(?=.*SNAPSHOT)(?!.*latest).*')
      mise run argo:update_and_sync_by_namespace "$K_NAME" "${VERSION_GREP_ARGS[@]}"
      ;;
    iaadstest*)
      mise run argo:copy_parameters "${K_NAME/test/dev}" "$K_NAME" && mise run argo:sync "$K_NAME"
    ;;
    iaadsstaging*)
      VERSION_GREP_ARGS=(-v -e SNAPSHOT -e latest -e feature-)
      mise run argo:update_and_sync_by_namespace "$K_NAME" "${VERSION_GREP_ARGS[@]}"
    ;;
    *)
      echo "Unsupported automatic update for environment $K_NAME"
    ;;
  esac
}
environment_remote_update
"""

[tasks."environment:remote_update_all"]
run = """
mise run \\
    environment:remote_update iaadsdevauthority \\
::: environment:remote_update iaadsdevconsumer \\
::: environment:remote_update iaadsdevdataprovider \\
::: environment:remote_update iaadsstagingauthority \\
::: environment:remote_update iaadsstagingconsumer \\
::: environment:remote_update iaadsstagingdataprovider \\
::: environment:remote_update iaadsautomationauthority \\
::: environment:remote_update iaadsautomationconsumer \\
::: environment:remote_update iaadsautomationdataprovider
"""

[tasks."environment:remote_update_tests"]
run = """
mise run \\
    environment:remote_update iaadstestauthority \\
::: environment:remote_update iaadstestconsumer \\
::: environment:remote_update iaadstestdataprovider \\
"""

[tasks."repository:write_targetRevision_to_values"]
dir = "{{cwd}}"
shell = "bash -ec"
run = """
repository_write_targetRevision_to_values() {
  local K_NAMESPACE="${1?Missing namespace}"
  local VALUE_FILE="${2?Missing value file}"
  shift; shift;
  if [ -f "${VALUE_FILE}" ]; then
    local Y_CONTENT="$(yq "$VALUE_FILE")"
    local Y_CONTENT_NEW="$Y_CONTENT"
    local Y_CONTENT_NEW="$(kubectl -n argocd get application "${K_NAMESPACE}"-deployer -oyaml | yq '.spec.source.helm.parameters[] | select(.name | test("targetRevision")) | "(.\\(.name)) = \\"\\(.value)\\""' | ( while read line; do Y_CONTENT_NEW="$(echo "$Y_CONTENT_NEW" | yq "$line")"; done; echo "$Y_CONTENT_NEW";))"
    if [ -z "$Y_CONTENT_NEW" ]; then
      >&2 echo "Ivalid content. Skip file update."
      return 1
    fi
    set +e
    diff --color=always -u <(echo "$Y_CONTENT") <(echo "$Y_CONTENT_NEW")
    set -e
    echo "$Y_CONTENT_NEW" > $VALUE_FILE;
  else
    >&2 echo "File does not exist. file=[${VALUE_FILE}]"
    return 1
  fi
}
repository_write_targetRevision_to_values
"""

[tasks."repository:write_targetRevision_to_all_charts"]
shell = "bash -ec"
run = """
mise run repository:write_targetRevision_to_values iaadsstagingauthority simpl-repo/authority-iaa/charts/values.yaml
mise run repository:write_targetRevision_to_values iaadsstagingconsumer simpl-repo/consumer-iaa/charts/values.yaml
mise run repository:write_targetRevision_to_values iaadsstagingdataprovider simpl-repo/provider-iaa/charts/values.yaml
"""

[tasks."services:token"]
shell = "bash -ec"
run = """
services_login() {
  local K_NAMESPACE="${1?Missing namespace}"
  local USERNAME="${2?Missing username}"
  local CLIENT_ID="frontend-cli"
  local BASE_URL="$(service_token_get_base_url "$K_NAMESPACE")"
  curl -s -X POST "$BASE_URL/protocol/openid-connect/token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=frontend-cli" \
    -d "username=${USERNAME}" \
    -d "password=password" \
    -d "grant_type=password"
}
services_token() {
  local K_NAMESPACE="${1?Missing namespace}"
  local USERNAME="${2?Missing username}"
  local TOKEN_FILE="${USERNAME}-${K_NAMESPACE}-token.json"
  local LOGIN_TOKEN="";
  if [ -f "$TOKEN_FILE" ] && [ "$(cat "$TOKEN_FILE" | jq -r .access_token)" != "null" ]; then
    LOGIN_TOKEN="$(cat "$TOKEN_FILE")"
    if [[ $(date -Iseconds) > $(date -Iseconds -d @"$(<<<"$LOGIN_TOKEN" jq -r .access_token | cut -d. -f2 | base64 -d 2>/dev/null | jq .exp)") ]]; then
      local REFRESH_TOKEN="$(<<<"$LOGIN_TOKEN" jq -r .refresh_token)"
      LOGIN_TOKEN="$(service_token_refresh "$K_NAMESPACE" "$REFRESH_TOKEN")"
      if [ -z "$LOGIN_TOKEN" ]; then
        >&2 echo "Invalid token response"
        return 1;
      fi
      echo "$LOGIN_TOKEN" > "$TOKEN_FILE"
    fi
  else
    LOGIN_TOKEN="$(services_login "$K_NAMESPACE" "$USERNAME")"
    if [ -z "$LOGIN_TOKEN" ]; then
      >&2 echo "Invalid token response"
      return 1;
    fi
    echo "$LOGIN_TOKEN" > "$TOKEN_FILE"
  fi
  <<<"$LOGIN_TOKEN" jq -r .access_token
}
service_token_refresh() {
  local K_NAMESPACE="${1?Missing namespace}"
  local REFRESH_TOKEN="${2?Missing refresh token}"
  local BASE_URL="$(service_token_get_base_url "$K_NAMESPACE")"
  curl -s -X POST "$BASE_URL/protocol/openid-connect/token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=frontend-cli" \
    -d "grant_type=refresh_token" \
    -d "refresh_token=${REFRESH_TOKEN}"
}
service_token_get_base_url() {
  local K_NAMESPACE="${1?Missing namespace}"
  local FQDN_PREFIX="participant";
  local REALM="participant"
  if [[ "$K_NAMESPACE" =~ authority ]]; then
    FQDN_PREFIX="authority";
    REALM="authority";
  fi
  echo -n "https://${FQDN_PREFIX}.be.${K_NAMESPACE}${FQDN_SUFFIX}/auth/realms/${REALM}"
}
services_token
"""
