# -----------------------------------------------------------------------------
# ESCAPE-REF: KC-MISE-QUOTE-001
#
# This task embeds a multiline shell script inside a single-quoted string
# passed to `bash -c` via `kubectl exec`.
#
# IMPORTANT:
# The outer layer uses single quotes ('...') to prevent the local shell from
# performing variable expansion or interpretation before the script reaches
# the container.
#
# Because of this, ANY single quote character inside the embedded script
# will terminate the outer string and break parsing.
#
# In shell, single quotes cannot be escaped inside single-quoted strings.
# The only safe ways to include a single quote are:
#
#   1) Close and reopen the quote:
#        'foo'\''bar'
#
#   2) Avoid single quotes entirely inside the embedded script.
#
# Why this matters:
# The evaluation chain is:
#     mise template expansion
#     → local bash parsing
#     → kubectl exec
#     → container bash -c parsing
#
# The outer single quotes ensure the script is passed RAW to the container.
# Breaking this quoting breaks the entire execution model.
#
# If modifying the embedded script, ensure it does not contain unescaped
# single quotes.
# -----------------------------------------------------------------------------

[tools]
kubectl = "1.34.1"
go = "1.25.4"
jq = "1.8.1"
yq = "4.47.2"
"go:github.com/pumahawk/klog" = "latest"

[env]
KUBECONFIG = "__REQUIRED_OVERRIDE__"
AUTHORITY_NAMESPACE = "authority01"
TIER2_FQDN="tls.authority.authority01.sandbox-iaa.simpl-europe.eu"

# See ESCAPE-REF: KC-MISE-QUOTE-001
[vars]
keycloak_sh = """
kgetpass() {
  cat /opt/bitnami/keycloak/secrets/admin-password
}
kcadm() {
  local action="${1?Missing action}"
  shift
  local pass="$(kgetpass)"
  /opt/keycloak/bin/kcadm.sh "$action" --no-config --server http://keycloak --realm master --user admin --password $pass "$@"
}
"""

[tasks."logs"]
shell = "bash -c"
run = "klog --kubeconfig=\"${KUBECONFIG}\" --config klog/conf.yaml -sort"

[tasks."cluster:authority-initialization"]
shell = "bash -ec"
run = """
NAMESPACE="${AUTHORITY_NAMESPACE}"

AUTH_PF_PORT=8105
ID_PF_PORT=8103

AUTH_SERVICE=authentication-provider
ID_SERVICE=identity-provider

cleanup() {
  >&2 echo "Stopping port-forwards..."
  [[ -n "$AUTH_PF_PID" ]] && kill "$AUTH_PF_PID" 2>/dev/null || true
  [[ -n "$ID_PF_PID" ]] && kill "$ID_PF_PID" 2>/dev/null || true
}

trap cleanup EXIT INT TERM

>&2 echo "Starting port-forward for $AUTH_SERVICE..."
kubectl port-forward -n "$NAMESPACE" svc/$AUTH_SERVICE $AUTH_PF_PORT:8080 >/tmp/auth-pf.log 2>&1 &
AUTH_PF_PID=$!

>&2 echo "Starting port-forward for $ID_SERVICE..."
kubectl port-forward -n "$NAMESPACE" svc/$ID_SERVICE $ID_PF_PORT:8080 >/tmp/id-pf.log 2>&1 &
ID_PF_PID=$!

wait_for_port() {
  local port=$1
  for i in {1..20}; do
    if nc -z localhost "$port"; then
      return 0
    fi
    sleep 0.5
  done
  >&2 echo "Port $port not available"
  exit 1
}

>&2 echo "Waiting for port-forwards to be ready..."
wait_for_port $AUTH_PF_PORT
wait_for_port $ID_PF_PORT

export AUTHORITY_AUTH_PROVIDER=localhost:$AUTH_PF_PORT
export AUTHORITY_IDENTITY_PROVIDER=localhost:$ID_PF_PORT

>&2 echo Generating keypair...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/keypairs/generate"

>&2 echo Generating CSR...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/csr/generate" \
--header 'Content-Type: application/json' \
--data-raw '{
  "commonName": "'"$TIER2_FQDN"'",
  "country": "it",
  "organization": "authority01",
  "organizationalUnit": "authority01"
}' > csr.pem

>&2 echo Creating Authority participant
PARTICIPANT_ID=$(curl -v -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants" \
--header 'Content-Type: application/json' \
--data-raw '{
  "organization": "authority01",
  "participantType": "GOVERNANCE_AUTHORITY"
}' | sed -E 's/^"(.*)"$/\\1/')

>&2 echo Uploading CSR ..
>&2 echo "Participant id: $PARTICIPANT_ID"
curl -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants/$PARTICIPANT_ID/csr" \
-F "csr=@csr.pem"

>&2 echo Downloading credentials ...
curl "$AUTHORITY_IDENTITY_PROVIDER/v1/credentials/$PARTICIPANT_ID/download" \
-o cert.pem

>&2 echo Uploading credentials ...
curl -v -H "Authorization: Bearer $TMP_TOKEN" -X POST "$AUTHORITY_AUTH_PROVIDER/v1/credentials" \
-F "credential=@cert.pem"
"""
# sandbox-iaa/consumer01-postgres-passwords
[tasks."cluster:secrets"]
shell = "bash -c"
run = """
function main() {
  SECRET_KEY="$1"
  shift;
  T_BAO=$(kubectl -n common01 get secret secrets-root-token -o jsonpath="{.data.token}" | base64 -d)
  (
  kubectl -n common01 exec -i openbao-common01-0 -- sh -b << EOF
  >&2 bao login "$T_BAO" \
  && bao kv get -format=json $@ "$SECRET_KEY"
EOF
  ) | cat
}
main
"""

[tasks."cluster:db:exec"]
run = "kubectl exec -n common01 pg-cluster-0 -- psql -U postgres"

[tasks."cluster:db:connect"]
run = "kubectl exec -it -n common01 pg-cluster-0 -- psql -U postgres"

[tasks."db:drop_all_tables"]
shell = "bash -ec"
run = """
drop_all_tables() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: drop_all_tables <namespace> <db_user>"
    return 1
  fi

  local DB_PASS="$(mise run db:get_password "$K_NAMESPACE" "$DB_USER")"

  # --- Parameter validation ---
  if [[ -z "$DB_PASS" ]]; then
    echo "ERROR: Missing required parameters."
    echo "ERROR: Missing password"
    return 1
  fi

  echo "Connecting to database as ${K_NAMESPACE}_${DB_USER}..."

  kubectl exec -i -n common01 pg-cluster-0 -- sh -c "
    export PGPASSWORD='${DB_PASS}';
    psql --host=pg-cluster -U ${K_NAMESPACE}_${DB_USER} <<'SQL'
DO \\$\\$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    )
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS public.'
                || quote_ident(r.tablename)
                || ' CASCADE';
    END LOOP;
END
\\$\\$;
SQL
"

  if [[ $? -ne 0 ]]; then
    echo "ERROR: Failed to drop tables."
    return 1
  fi

  echo "All tables in schema 'public' have been dropped successfully."
}
drop_all_tables
"""

[tasks."db:get_password"]
shell = "bash -ec"
run = """
get_password() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_password <namespace> <db_user>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/"$K_NAMESPACE"-postgres-passwords | jq -r '.data.data."'"${K_NAMESPACE}-${DB_USER}"'"'
}
get_password
"""

[tasks."db:get_secrets"]
shell = "bash -ec"
run = """
get_secrets() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_secrets <namespace>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/${K_NAMESPACE}-postgres-passwords
}
get_secrets
"""

[tasks."db:clear_agent"]
shell = "bash -ec"
run = """
clear_agent() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: clear_agent <namespace>"
    return 1
  fi

   # Participant
   mise run db:drop_all_tables "$K_NAMESPACE" authenticationprovider
   mise run db:drop_all_tables "$K_NAMESPACE" usersroles

   if echo "$K_NAMESPACE" | grep -q authority; then
     # Authority
     # mise run db:drop_all_tables "$K_NAMESPACE" ejbca
     # mise run db:drop_all_tables "$K_NAMESPACE" keycloak
     mise run db:drop_all_tables "$K_NAMESPACE" identityprovider
     mise run db:drop_all_tables "$K_NAMESPACE" onboarding
     mise run db:drop_all_tables "$K_NAMESPACE" securityattributesprovider
   fi
}
clear_agent
"""

[tasks."keycloak:cli"]
shell = "bash -ec"
run = """
keycloak_cli() {
local K_NAMESPACE="${1?"Missing namespace"}"
kubectl -it -n "$K_NAMESPACE" exec keycloak-0 -- bash -c "
bash --init-file <( echo -e '"'{{vars.keycloak_sh}}'"' ) -i
"
}
keycloak_cli
"""

[tasks."services:info"]
shell = "bash -ec"
run = """
services_endpoints() {
  local project_name="${1?Missing project}"
  local chart_file="simpl-repo/$project_name/charts/values.yaml"
  [ -f "$chart_file" ] || {
     echo "Invalid project."
     exit 1;
  }
  cat "$chart_file" | yq -ojson | jq 'to_entries[] | select((.value|type)=="object" and .value.projectID!=null) | {name:.key, projectID:.value.projectID, repo:"https://code.europa.eu/api/v4/projects/\\(.value.projectID)/packages/helm/stable"}' 
}
services_endpoints
"""

[tasks."services:versions_by_projectID"]
shell = "bash -ec"
run = """
services_versions_by_projectID() {
  local project_id="${1?Missing project ID}"
  curl -s "https://code.europa.eu/api/v4/projects/$project_id/packages/helm/stable/index.yaml" | yq -o json -r '.entries[] | sort_by(.created) | reverse | .[].version' 
}
services_versions_by_projectID
"""

[tasks."keycloak:config:eidas"]
shell = "bash -ec"
run = """
keycloak_config_eidas() {
local K_NAMESPACE="${1?"Missing namespace"}"
kubectl -n "$K_NAMESPACE" exec keycloak-0 -- bash -c '
{{vars.keycloak_sh}}
'"
kgetpass
"
}
keycloak_config_eidas
"""

[tasks."services:last_version"]
shell = "bash -ec"
run = """
services_last_version() {
  local repo_name="${1?"Missing repo name"}"
  local project_name="${2?"Missing project name"}"
  local project_id="$(mise run services:info authority-iaa | jq -r 'select(.name == "'"$project_name"'") | .projectID')"
  echo $project_name $(mise services:versions_by_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)
}
services_last_version
"""

[tasks."services:all_last_version"]
shell = "bash -ec"
run = """
services_all_last_version() {
  local repo_name="${1?"Missing repo name"}"
  mise run services:info $repo_name | jq -r '"\\(.name)|\\(.projectID)"' |
  while read line; do
    local project_name="$(echo -e $line | cut -d\\| -f1)"
    local project_id="$(echo -e $line | cut -d\\| -f2)"
    echo $project_name "$(mise services:versions_by_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)"
  done
}
services_all_last_version
"""
