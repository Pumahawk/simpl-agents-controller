# -----------------------------------------------------------------------------
# ESCAPE-REF: KC-MISE-QUOTE-001
#
# This task embeds a multiline shell script inside a single-quoted string
# passed to `bash -c` via `kubectl exec`.
#
# IMPORTANT:
# The outer layer uses single quotes ('...') to prevent the local shell from
# performing variable expansion or interpretation before the script reaches
# the container.
#
# Because of this, ANY single quote character inside the embedded script
# will terminate the outer string and break parsing.
#
# In shell, single quotes cannot be escaped inside single-quoted strings.
# The only safe ways to include a single quote are:
#
#   1) Close and reopen the quote:
#        'foo'\''bar'
#
#   2) Avoid single quotes entirely inside the embedded script.
#
# Why this matters:
# The evaluation chain is:
#     mise template expansion
#     → local bash parsing
#     → kubectl exec
#     → container bash -c parsing
#
# The outer single quotes ensure the script is passed RAW to the container.
# Breaking this quoting breaks the entire execution model.
#
# If modifying the embedded script, ensure it does not contain unescaped
# single quotes.
# -----------------------------------------------------------------------------

[tools]
kubectl = "1.34.1"
go = "1.25.4"
jq = "1.8.1"
yq = "4.47.2"
"go:github.com/pumahawk/klog" = "latest"

[env]
KUBECONFIG = "__REQUIRED_OVERRIDE__"
AUTHORITY_NAMESPACE = "authority01"
TIER2_FQDN="tls.authority.authority01.sandbox-iaa.simpl-europe.eu"

# See ESCAPE-REF: KC-MISE-QUOTE-001
[vars]
keycloak_sh = """
kgetpass() {
  cat /opt/bitnami/keycloak/secrets/admin-password
}
kcadm() {
  local action="${1?Missing action}"
  shift
  local pass="$(kgetpass)"
  /opt/keycloak/bin/kcadm.sh "$action" --no-config --server http://keycloak --realm master --user admin --password $pass "$@"
}
"""

[tasks."logs"]
shell = "bash -c"
run = "klog --kubeconfig=\"${KUBECONFIG}\" --config klog/conf.yaml -sort"

[tasks."cluster:authority-initialization"]
shell = "bash -ec"
run = """
NAMESPACE="${AUTHORITY_NAMESPACE}"

AUTH_PF_PORT=8105
ID_PF_PORT=8103

AUTH_SERVICE=authentication-provider
ID_SERVICE=identity-provider

cleanup() {
  >&2 echo "Stopping port-forwards..."
  [[ -n "$AUTH_PF_PID" ]] && kill "$AUTH_PF_PID" 2>/dev/null || true
  [[ -n "$ID_PF_PID" ]] && kill "$ID_PF_PID" 2>/dev/null || true
}

trap cleanup EXIT INT TERM

>&2 echo "Starting port-forward for $AUTH_SERVICE..."
kubectl port-forward -n "$NAMESPACE" svc/$AUTH_SERVICE $AUTH_PF_PORT:8080 >/tmp/auth-pf.log 2>&1 &
AUTH_PF_PID=$!

>&2 echo "Starting port-forward for $ID_SERVICE..."
kubectl port-forward -n "$NAMESPACE" svc/$ID_SERVICE $ID_PF_PORT:8080 >/tmp/id-pf.log 2>&1 &
ID_PF_PID=$!

wait_for_port() {
  local port=$1
  for i in {1..20}; do
    if nc -z localhost "$port"; then
      return 0
    fi
    sleep 0.5
  done
  >&2 echo "Port $port not available"
  exit 1
}

>&2 echo "Waiting for port-forwards to be ready..."
wait_for_port $AUTH_PF_PORT
wait_for_port $ID_PF_PORT

export AUTHORITY_AUTH_PROVIDER=localhost:$AUTH_PF_PORT
export AUTHORITY_IDENTITY_PROVIDER=localhost:$ID_PF_PORT

>&2 echo Generating keypair...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/keypairs/generate"

>&2 echo Generating CSR...
curl -v -X POST "$AUTHORITY_AUTH_PROVIDER/v1/csr/generate" \
--header 'Content-Type: application/json' \
--data-raw '{
  "commonName": "'"$TIER2_FQDN"'",
  "country": "it",
  "organization": "authority01",
  "organizationalUnit": "authority01"
}' > csr.pem

>&2 echo Creating Authority participant
PARTICIPANT_ID=$(curl -v -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants" \
--header 'Content-Type: application/json' \
--data-raw '{
  "organization": "authority01",
  "participantType": "GOVERNANCE_AUTHORITY"
}' | sed -E 's/^"(.*)"$/\\1/')

>&2 echo Uploading CSR ..
>&2 echo "Participant id: $PARTICIPANT_ID"
curl -X POST "$AUTHORITY_IDENTITY_PROVIDER/v1/participants/$PARTICIPANT_ID/csr" \
-F "csr=@csr.pem"

>&2 echo Downloading credentials ...
curl "$AUTHORITY_IDENTITY_PROVIDER/v1/credentials/$PARTICIPANT_ID/download" \
-o cert.pem

>&2 echo Uploading credentials ...
curl -v -H "Authorization: Bearer $TMP_TOKEN" -X POST "$AUTHORITY_AUTH_PROVIDER/v1/credentials" \
-F "credential=@cert.pem"
"""
# sandbox-iaa/consumer01-postgres-passwords
[tasks."cluster:secrets"]
shell = "bash -c"
run = """
function main() {
  SECRET_KEY="$1"
  shift;
  T_BAO=$(kubectl -n common01 get secret secrets-root-token -o jsonpath="{.data.token}" | base64 -d)
  (
  kubectl -n common01 exec -i openbao-common01-0 -- sh -b << EOF
  >&2 bao login "$T_BAO" \
  && bao kv get -format=json $@ "$SECRET_KEY"
EOF
  ) | cat
}
main
"""

[tasks."cluster:db:exec"]
run = "kubectl exec -n common01 pg-cluster-0 -- psql -U postgres"

[tasks."cluster:db:connect"]
run = "kubectl exec -it -n common01 pg-cluster-0 -- psql -U postgres"

[tasks."db:drop_all_tables"]
shell = "bash -ec"
run = """
drop_all_tables() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: drop_all_tables <namespace> <db_user>"
    return 1
  fi

  local DB_PASS="$(mise run db:get_password "$K_NAMESPACE" "$DB_USER")"

  # --- Parameter validation ---
  if [[ -z "$DB_PASS" ]]; then
    echo "ERROR: Missing required parameters."
    echo "ERROR: Missing password"
    return 1
  fi

  echo "Connecting to database as ${K_NAMESPACE}_${DB_USER}..."

  kubectl exec -i -n common01 pg-cluster-0 -- sh -c "
    export PGPASSWORD='${DB_PASS}';
    psql --host=pg-cluster -U ${K_NAMESPACE}_${DB_USER} <<'SQL'
DO \\$\\$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    )
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS public.'
                || quote_ident(r.tablename)
                || ' CASCADE';
    END LOOP;
END
\\$\\$;
SQL
"

  if [[ $? -ne 0 ]]; then
    echo "ERROR: Failed to drop tables."
    return 1
  fi

  echo "All tables in schema 'public' have been dropped successfully."
}
drop_all_tables
"""

[tasks."db:get_password"]
shell = "bash -ec"
run = """
get_password() {
  local K_NAMESPACE="$1"
  local DB_USER="$2"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" || -z "$DB_USER" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_password <namespace> <db_user>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/"$K_NAMESPACE"-postgres-passwords | jq -r '.data.data."'"${K_NAMESPACE}-${DB_USER}"'"'
}
get_password
"""

[tasks."db:get_secrets"]
shell = "bash -ec"
run = """
get_secrets() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: get_secrets <namespace>"
    return 1
  fi

  mise run cluster:secrets sandbox-iaa/${K_NAMESPACE}-postgres-passwords
}
get_secrets
"""

[tasks."db:clear_agent"]
shell = "bash -ec"
run = """
clear_agent() {
  local K_NAMESPACE="$1"

  # --- Parameter validation ---
  if [[ -z "$K_NAMESPACE" ]]; then
    echo "ERROR: Missing required parameters."
    echo "Usage: clear_agent <namespace>"
    return 1
  fi

   # Participant
   mise run db:drop_all_tables "$K_NAMESPACE" authenticationprovider
   mise run db:drop_all_tables "$K_NAMESPACE" usersroles

   if echo "$K_NAMESPACE" | grep -q authority; then
     # Authority
     mise run db:drop_all_tables "$K_NAMESPACE" ejbca
     kubectl -n "$K_NAMESPACE" delete secret ejbca-rest-api-secret
     mise run db:drop_all_tables "$K_NAMESPACE" keycloak
     mise run db:drop_all_tables "$K_NAMESPACE" identityprovider
     mise run db:drop_all_tables "$K_NAMESPACE" onboarding
     mise run db:drop_all_tables "$K_NAMESPACE" securityattributesprovider
   fi
}
clear_agent
"""

[tasks."keycloak:cli"]
shell = "bash -ec"
run = """
keycloak_cli() {
local K_NAMESPACE="${1?"Missing namespace"}"
kubectl -it -n "$K_NAMESPACE" exec keycloak-0 -- bash -c "
bash --init-file <( echo -e '"'{{vars.keycloak_sh}}'"' ) -i
"
}
keycloak_cli
"""

[tasks."services:info"]
shell = "bash -ec"
run = """
services_endpoints() {
  local project_name="${1?Missing project}"
  local chart_file="simpl-repo/$project_name/charts/values.yaml"
  [ -f "$chart_file" ] || {
     echo "Invalid project."
     exit 1;
  }
  cat "$chart_file" | yq -ojson | jq 'to_entries[] | select((.value|type)=="object" and .value.projectID!=null) | {name:.key, projectID:.value.projectID, version: .value.targetRevision, repo:"https://code.europa.eu/api/v4/projects/\\(.value.projectID)/packages/helm/stable"}' 
}
services_endpoints
"""

[tasks."services:info-table"]
shell = "bash -ec"
run = """
services_info_table() {
   local project_name="${1?Missing project}"
   mise services:info "$project_name" | jq -r '"\\(.name),\\(.version)"' | column -s, -t
}
services_info_table
"""

[tasks."services:versions_by_type_and_projectID"]
shell = "bash -ec"
run = """
services_versions_by_type_and_projectID() {
  local TYPE_AND_PROJECT_ID="${1?Missing type and project}"
  local TYPE="$(echo "$TYPE_AND_PROJECT_ID" | cut -d, -f 1)"
  local PROJECT_ID="$(echo "$TYPE_AND_PROJECT_ID" | cut -d, -f 3)"
  case "${TYPE?"Missing type"}" in
    helm)
      mise run services:helm_versions_by_projectID "${PROJECT_ID?"Missing projectID"}"
    ;;
    jar)
      mise run services:jar_versions_by_projectID "${PROJECT_ID?"Missing projectID"}"
    ;;
    *)
      >&2 echo "Not supported type [$TYPE]"
      return 1
    ;;
   esac
}
services_versions_by_type_and_projectID
"""

[tasks."services:jar_versions_by_projectID"]
shell = "bash -ec"
run = """
services_jar_versions_by_projectID() {
  local project_id="${1?Missing project ID}"
  curl -s -w "%{stderr}Http response code: %{http_code}\\n" "https://code.europa.eu/api/v4/projects/${project_id}/maven-metadata.xml" | yq -r -p xml .metadata.versioning.versions.version[] | tac
}
services_jar_versions_by_projectID
"""

[tasks."services:helm_versions_by_projectID"]
shell = "bash -ec"
run = """
services_helm_versions_by_projectID() {
  local project_id="${1?Missing project ID}"
  curl -s -w "%{stderr}Http response code: %{http_code}\\n" "https://code.europa.eu/api/v4/projects/$project_id/packages/helm/stable/index.yaml" | yq -o json -r '.entries[] | sort_by(.created) | reverse | .[].version'
}
services_helm_versions_by_projectID
"""

[tasks."keycloak:config:eidas"]
shell = "bash -ec"
run = """
keycloak_config_eidas() {
local K_NAMESPACE="${1?"Missing namespace"}"
kubectl -n "$K_NAMESPACE" exec keycloak-0 -- bash -c '
{{vars.keycloak_sh}}
'"
kgetpass
"
}
keycloak_config_eidas
"""

[tasks."services:last_version"]
shell = "bash -ec"
run = """
services_last_version() {
  local repo_name="${1?"Missing repo name"}"
  local project_name="${2?"Missing project name"}"
  local project_id="$(mise run services:info authority-iaa | jq -r 'select(.name == "'"$project_name"'") | .projectID')"
  echo $project_name $(mise services:versions_by_type_and_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)
}
services_last_version
"""

[tasks."services:all_last_version"]
shell = "bash -ec"
run = """
services_all_last_version() {
  local repo_name="${1?"Missing repo name"}"
  mise run services:info $repo_name | jq -r '"\\(.name)|\\(.projectID)"' |
  while read line; do
    local project_name="$(echo -e $line | cut -d\\| -f1)"
    local project_id="$(echo -e $line | cut -d\\| -f2)"
    echo $project_name "$(mise services:versions_by_type_and_projectID $project_id | grep -v -e latest -e \\-rc -e hotfix | head -n1)"
  done
}
services_all_last_version
"""

[tasks."yaml:argo_app:update_target_revision"]
shell = "bash -ec"
dir = "{{cwd}}"
run = """
update_target_revision() {
  local file="${1?Missing file path}"
  local name="${2?Missing name}"
  local version="${3?Missing version}"
  yq '(.spec.source.helm.parameters[] | select(.name | test("((^)|(\\.))'"$name"'.targetRevision")) | .value) = "'"$version"'"' "$file"
}
update_target_revision
"""

[tasks."argo:get_updated_application_by_namespace"]
shell = "bash -ec"
run = """
# Functions argo:get_updated_application_by_namespace
function argo_getapp() {
  local K_NAMESPACE="${1?Missing namespace}"
  local ARGO_DEPLOYER="$K_NAMESPACE"-deployer
  log "Get argocd deployer [$ARGO_DEPLOYER]"
  kubectl -n argocd get -oyaml application "$ARGO_DEPLOYER" | yq .
}

function helm_get_last_version_by_project_name() {
  local NAME="${1?Missin project name}"
  shift
  local VERSION_GREP_ARGS=("$@")
  log "Get last version project $NAME"
  local PROJECT_ID_AND_TYPE="$(iaa_get_type_and_projectID_by_projectName "${NAME}")"
  log "Retrieved projectID name=[$NAME] id=[$PROJECT_ID_AND_TYPE]"
  local PROJECT_VERSION="$(mise run services:versions_by_type_and_projectID $PROJECT_ID_AND_TYPE | grep "${VERSION_GREP_ARGS[@]-".*"}" | head -n1)"
  log "Retrieved version name=[$NAME] version=[$PROJECT_VERSION]"
  echo $PROJECT_VERSION
}

function argo_update_versions() {
  K_NAMESPACE=${1?Missing namespace}
  shift
  local VERSION_GREP_ARGS=("$@")
  local YAML_TEXT="$(argo_getapp "$K_NAMESPACE")"
  local YAML_ORIGINAL="$YAML_TEXT"
  local VERSION=""
  local CHART_PROJECT_ID="$(echo "$YAML_TEXT" | yq .spec.source.repoURL | grep -o '/[0-9][0-9]*/' | sed 's|/||g')"
  local CHART_VERSION="$(mise run services:versions_by_type_and_projectID helm,,"$CHART_PROJECT_ID" | grep "${VERSION_GREP_ARGS[@]-".*"}" | head -n1)"
   if [[ -n "$CHART_VERSION" && "$CHART_VERSION" != "null" ]]; then
     YAML_TEXT="$(yq '(.spec.source.targetRevision) = "'"$CHART_VERSION"'"'  <(echo "$YAML_TEXT"))"
   else
     log "Invalid version retrieved. Skip update. name=[$NAME]"
   fi
   while read line; do
    local NAME="$line"
    log "Update version. name=[$NAME]"
    VERSION="$(helm_get_last_version_by_project_name "$NAME" "${VERSION_GREP_ARGS[@]}")"
    if [[ -n "$VERSION" && "$VERSION" != "null" ]]; then
    YAML_TEXT="$(mise run yaml:argo_app:update_target_revision  <(echo "$YAML_TEXT") "$NAME" "$VERSION")"
    else
      log "Invalid version retrieved. Skip update. name=[$NAME]"
    fi
  done < <(echo "$YAML_TEXT" | yq .spec.source.helm.parameters[].name | grep targetRevision | sed 's/\\.targetRevision//;s/^.*\\.//')
  log "Diff .spec.source"
  local diff_exit=0
  set +e
  >&2 diff --color=always -U100 \
    <(echo "$YAML_ORIGINAL" | yq .spec.source) \
    <(echo "$YAML_TEXT" | yq .spec.source)
  diff_exit=$?
  set -e
  local DEST_SUFFIX="-argo-update-$(date '+%Y-%M-%d-%H%m%S').yaml"
  local YAML_DEST_FILE="${K_NAMESPACE}-updated${DEST_SUFFIX}"
  local YAML_OLD_DEST_FILE="${K_NAMESPACE}-old${DEST_SUFFIX}"
  log "Save updated file to $YAML_DEST_FILE"
  echo "$YAML_TEXT" > "$YAML_DEST_FILE"
  log "Save old file to $YAML_OLD_DEST_FILE"
  echo "$YAML_ORIGINAL" > "$YAML_OLD_DEST_FILE"
  echo "$YAML_TEXT" | yq .
  [ $diff_exit != 0 ]
}

function iaa_get_type_and_projectID_by_projectName() {
local NAME="${1?Missin project name}"
cat << 'EOF' | grep -E ",${NAME},"
helm,tier1_gateway,772
helm,sap,861
helm,users_roles,771
helm,fe_auth_provider,1308
helm,fe_users_roles,1310
helm,fe_identity_provider,1311
helm,fe_onboarding,1307
helm,fe_security_attribute_provider,1309
helm,onboarding,770
helm,tier2_gateway,860
helm,identity_provider,913
helm,auth_provider,939
helm,tier2_proxy,1112
jar,keycloak_authenticator,915/packages/maven/eu/europa/ec/simpl/keycloak-authenticator
jar,eidas_demo_keycloak_extension,1313/packages/maven/eu/europa/ec/simpl/eidas-demo-keycloak-extension
EOF
}

function log() {
  >&2 echo "$(date -Iseconds) - $1"
}
argo_update_versions
"""

[tasks."argo:update_and_sync_by_namespace"]
shell = "bash -ec"
run = """
argo_update_and_sync() {
local K_NAMESPACE="${1?Missing namespace}"
shift
local VERSION_GREP_ARGS=("$@")
if YAML_TEXT=$(mise run argo:get_updated_application_by_namespace "$K_NAMESPACE" "${VERSION_GREP_ARGS[@]}"); then
  >&2 echo Apply and sync.
  kubectl apply -f <(echo "$YAML_TEXT") && mise run argo:sync "$K_NAMESPACE"
else
  >&2 echo No differences . Skip apply and sync.
fi
}
argo_update_and_sync
"""

[tasks."argo:cli"]
run = "kubectl -n argocd exec argo-cd-argocd-application-controller-0 -- argocd --core "

[tasks."argo:sync"]
shell = "bash -ec"
run = """
argo_sync() {
  K_NAME="${1?Missing namespace}"
  kubectl -n argocd exec argo-cd-argocd-application-controller-0 -- argocd --core app sync "${K_NAME}"-deployer
}
argo_sync
"""

[tasks."argo:sync_all"]
run = """
mise run \\
    argo:sync iaadsdevauthority \\
::: argo:sync iaadsdevconsumer \\
::: argo:sync iaadsdevdataprovider \\
::: argo:sync iaadsstagingauthority \\
::: argo:sync iaadsstagingconsumer \\
::: argo:sync iaadsstagingdataprovider
"""

[tasks."environment:remote_update"]
shell = "bash -ec"
run = """
environment_remote_update() {
  local K_NAME="${1?Missing namespace}"
  local VERSION_GREP_ARGS=( -v -e latest )
  case "$K_NAME" in
    iaadsdev*)
      VERSION_GREP_ARGS=(-P '^(?=.*SNAPSHOT)(?!.*latest).*')
      mise run argo:update_and_sync_by_namespace "$K_NAME" "${VERSION_GREP_ARGS[@]}"
      ;;
    iaadsstaging*)
      VERSION_GREP_ARGS=(-v -e SNAPSHOT -e latest)
      mise run argo:update_and_sync_by_namespace "$K_NAME" "${VERSION_GREP_ARGS[@]}"
    ;;
    *)
      echo "Unsupported automatic update for environment $K_NAME"
    ;;
  esac
}
environment_remote_update
"""

[tasks."environment:remote_update_all"]
run = """
mise run \\
    environment:remote_update iaadsdevauthority \\
::: environment:remote_update iaadsdevconsumer \\
::: environment:remote_update iaadsdevdataprovider \\
::: environment:remote_update iaadsstagingauthority \\
::: environment:remote_update iaadsstagingconsumer \\
::: environment:remote_update iaadsstagingdataprovider
"""
